{
  "_args": [
    [
      {
        "raw": "ionic-cache",
        "scope": null,
        "escapedName": "ionic-cache",
        "name": "ionic-cache",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "C:\\Users\\Christian\\Documents\\GOSH_Internship\\GITHUB\\GOSHAPP_8_Cache"
    ]
  ],
  "_from": "ionic-cache@latest",
  "_id": "ionic-cache@3.1.2",
  "_inCache": true,
  "_location": "/ionic-cache",
  "_nodeVersion": "8.9.4",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/ionic-cache_3.1.2_1529333167534_0.6074934768397582"
  },
  "_npmUser": {
    "name": "darthdie",
    "email": "briarbear7@gmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "ionic-cache",
    "scope": null,
    "escapedName": "ionic-cache",
    "name": "ionic-cache",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "http://registry.npmjs.org/ionic-cache/-/ionic-cache-3.1.2.tgz",
  "_shasum": "f8b0d59dbb28fc5d903214bc72d7202d490c438e",
  "_shrinkwrap": null,
  "_spec": "ionic-cache",
  "_where": "C:\\Users\\Christian\\Documents\\GOSH_Internship\\GITHUB\\GOSHAPP_8_Cache",
  "author": {
    "name": "Daniel Suchy"
  },
  "browser": {
    "@angular/common/http": false
  },
  "bugs": {
    "url": "https://github.com/Nodonisko/ionic-cache/issues"
  },
  "dependencies": {},
  "description": "Ionic cache service - cache request, data, promises etc.",
  "devDependencies": {
    "@angular/common": "^5.0.0",
    "@angular/compiler": "^5.0.0",
    "@angular/compiler-cli": "^5.0.0",
    "@angular/core": "^5.0.0",
    "@angular/forms": "^5.0.0",
    "@angular/http": "^5.0.0",
    "@angular/platform-browser": "^5.0.0",
    "@angular/platform-browser-dynamic": "^5.0.0",
    "@ionic/storage": "^2.1.3",
    "@types/jasmine": "^2.5.47",
    "@types/node": "^7.0.18",
    "@types/websql": "0.0.27",
    "jasmine-core": "^2.6.1",
    "karma": "^1.6.0",
    "karma-chrome-launcher": "^2.1.0",
    "karma-cli": "^1.0.1",
    "karma-jasmine": "^1.1.0",
    "karma-phantomjs-launcher": "^1.0.4",
    "karma-typescript": "^3.0.12",
    "karma-typescript-angular2-transform": "^1.0.2",
    "karma-typescript-es6-transform": "^1.0.4",
    "rimraf": "^2.6.2",
    "rxjs": "^5.5.0",
    "tslint": "^3.15.1",
    "tslint-ionic-rules": "^0.0.8",
    "typescript": "~2.6.0",
    "zone.js": "^0.8.11"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-/LSrvQDJS7OhuquoA4RBLZQprd6MWVinCJUzr961eZgXWc8ks3HM4M8k9WKBigJLkAqEeDYhslJcFM/7IEqZXQ==",
    "shasum": "f8b0d59dbb28fc5d903214bc72d7202d490c438e",
    "tarball": "https://registry.npmjs.org/ionic-cache/-/ionic-cache-3.1.2.tgz",
    "fileCount": 19,
    "unpackedSize": 91450,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbJ8XaCRA9TVsSAnZWagAARvwP/R2Ur+f9yidjZZHQTiom\nxuehdg/CiP5s2vWxV/Vb6BecdBWOaY65RA/2gKb2Y0dBtQLrtXAgnNtuvuEg\nRCOHto6fh772QU3Zvf+OCsA8ho9urkP/2EndtM0+uV2EMLc/Z8DXThbkelhu\nAEPnpxqroStzhs9d5+E2GR5oY+kM1uJgZK7Jyt+9/gFcMzMhUB4rqx8ffmtk\noBDe5WcsLR2ZIkWyb9ReSKjBjjPm9YIAC7PD7IcU9jL8v3d12nrBIjHjYmul\n4084tvoG7ryiS317PYechaZ0oFojXE0eocIK2fJkieRjGfz6sqQOBARd78Uh\n8SaN4Sit6AINd1X0pn56xIEU67btZtCOyjLp7HLunGWuaYxD1C18pjAXCwiz\nymD9Aw1TC0IObLy+5LH084LhYHFwMoEWgIjO3WU7VQ3FgbJuSuQqWyBCL2h0\nBOERgCxv6u6VteUGONUzQDMwtn8VMo8soEWXFxGq4GbkgfvusnIeSKTg5hTm\nSiCqi2x06B2XUmDeVSuGlfbM5vEnEckEUSIHsdRJJTv1EZiIGBZ6RNqkHAaA\np2FYVM79qmtzG3QTv13rP2TPlwWYuPdTL/9qcV3Yct5h0iRHFfil+MfsAdE3\nKRzylqLjfB8C3kxn6XB9R/DrnskSKjZT7jAsKZSD7JdWRHBkTdTRMskcZfDM\nnaiF\r\n=4pg6\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "files": [
    "dist"
  ],
  "gitHead": "0d1fde5c9d84a53733be4486d9da2cd2eefc4c92",
  "homepage": "https://github.com/Nodonisko/ionic-cache#readme",
  "keywords": [
    "ionic",
    "ionic",
    "cache",
    "angular2"
  ],
  "license": "MIT",
  "main": "dist/index.js",
  "maintainers": [
    {
      "name": "nodon",
      "email": "suchydan@gmail.com"
    }
  ],
  "module": "dist/index.js",
  "name": "ionic-cache",
  "optionalDependencies": {},
  "peerDependencies": {
    "@ionic/storage": "^2.1.3"
  },
  "readme": "# Ionic cache service\n\nIonic cache service that can cache almost everything. **It caches requests, observables, promises and classic data.** It uses [Ionic Storage](https://ionicframework.com/docs/storage/) so we support IndexedDB, SQLite (Cordova), WebSQL in this order.\nIt can be used separatelety in Angular 2 application.\n\nKey features:\n+ Request caching\n+ Delayed observable caching (see docs for more info)\n+ Don't invalidate cache if is browser offline\n+ Set and invalidate groups of entries\n+ Supports IndexedDB, SQLite (Cordova), WebSQL via Ionic Storage\n\nPlease report all bugs to bug report or fix it and send pull request :)\n\n#### Big thanks to all contributors for help:\n+ Special thanks to [ihadeed](https://github.com/ihadeed)\n+ [imatefx](https://github.com/imatefx)\n+ [Vojta Tranta](https://github.com/vojtatranta)\n\n## Install\n\nVia NPM:\n\n```bash\nnpm install ionic-cache @ionic/storage --save\n```\n\nor Yarn:\n```bash\nyarn add ionic-cache @ionic/storage\n```\n\nYou can optionally add [Cordova SQLite](https://ionicframework.com/docs/native/sqlite/).\n\nAnd inject service to your app:\n\n*app.module.ts*\n\n```ts\nimport { CacheModule } from \"ionic-cache\";\n\n@NgModule({\n  ...\n  imports: [\n    CacheModule.forRoot()\n  ],\n})\n```\n\n*app.component.ts*\n\n```ts\nimport { CacheService } from \"ionic-cache\";\n\n@Component({\n    templateUrl: \"build/app.html\"\n})\nclass MyApp {\n    constructor(cache: CacheService) {\n        ...\n        cache.setDefaultTTL(60 * 60); //set default cache TTL for 1 hour\n        ....\n    }\n    ...\n}\n```\n\n## Usage\n\n### Config\n\nStarting with version 3.0.2, `CacheModule.forRoot()` optionally accepts a config object.\n\nThe config object currently accepts a `keyPrefix`, which is the the internal key prefix to use when storing items.\n\nFor backwards compatibility this defaults to `''`, but it's recommended to set this to a different value in order to prevent issues with `clearAll()`.\n\n```ts\n@NgModule({\n  ...\n  imports: [\n    CacheModule.forRoot({ keyPrefix: 'my-app-cache' })\n  ],\n})\n```\n\n### Observables\n\n#### Cache request\n\n```ts\n...\nimport { CacheService } from \"ionic-cache\";\n\n@Injectable()\nexport class SomeProvider {\n    constructor(private http: HttpClient, private cache: CacheService) {}\n\n    loadList() {\n        let url = \"http://ip.jsontest.com\";\n        let cacheKey = url;\n        let request = this.http.get(url);\n\n        return this.cache.loadFromObservable(cacheKey, request);\n    }\n    ...\n```\n\n#### Cache whole request response\n\nIf you need to cache the whole response, for example if you need to access the Headers, you can pass in an object with the observe key set to 'response', i.e. `{ observe: 'response' }`. Then you can use `.pipe(map(res => res.body))` to extract the response body.\n\n```ts\n...\nlet request = this.http.get(url, { observe: 'response' });\nreturn this.cache.loadFromObservable(cacheKey, request).pipe(map(res => res.body));\n...\n```\n\n#### Cache with custom Observable operators\n\n`loadFromObservable` accepts an Observable and returns an Observable, so you are free to use all of the Observable operators. \nFor example error handling (on error, retry request every 6 seconds if fails):\n\n```ts\n...\nlet request = this.http.get(url)\n.pipe(retryWhen(error => error.timer(6000)));\n\nreturn this.cache.loadFromObservable(cacheKey, request);\n...\n```\n\n#### Delayed observable caching\n\n`loadFromDelayedObservable` shows off the full power of observables.\nWhen you call this method and it will return the cached date (even if it's expired) \nand immediately send a request to the server and then return the new data.\n\n```ts\n...\n    let request = this.http.get(url);\n    let delayType = 'all'; // this indicates that it should send a new request to the server every time, you can also set it to 'none' which indicates that it should only send a new request when it's expired\n\n    let response = this.cache.loadFromDelayedObservable(cacheKey, request, groupKey, ttl, delayType);\n\n    response.subscribe(data => {\n        console.log(\"Data:\" data);\n    });\n\n    //result will look like this:\n    // Data: \"Hello world from cache\"\n    // Data: \"Hello world from server\"\n...\n```\n\n### Promises & Classic data\n\n#### Cache promises\n\n```ts\n...\nlet key = 'some-promise';\nlet data = await this.cache.getOrSetItem(key, () => somePromiseFunction());\nconsole.log(\"Saved data: \", data);\n...\n```\n\n#### Cache classic data (arrays, objects, strings, numbers etc.)\n\nSimilarly, you can use `getOrSetItem` or `getItem` with classic data.\n\n```ts\n...\nlet key = 'heavily-calculated-function';\n\nlet data = await this.cache.getOrSetItem(key, () => heavilyCalculatedFunction());\nconsole.log('Saved data: ', data);\n...\n```\n\nIf you need more control in the event that the item is expired or doesn't exist, you can use the `getItem` method with error handling.\n\n```ts\n...\nlet key = 'heavily-calculated-function';\n\nlet data = await this.cache.getItem(key)\n.catch(() => {\n    console.log(\"Oh no! My promise is expired or doesn't exist!\");\n\n    let result = heavilyCalculatedFunction();\n    return this.cache.saveItem(key, result);\n});\n\nconsole.log('Saved data: ', data);\n...\n```\n\n#### Removing cached items\n\nYou can also remove cached items by using the `removeItem` method.\n\n```ts\n...\nlet key = 'some-promise';\n\nthis.cache.removeItem(key);\n...\n```\n\n#### Removing multiple cached items\n\nYou can utilize the `removeItems` method to remove multiple items based on a wildcard pattern.\n\n```ts\n...\nawait Promise.all([\n    service.saveItem('movies/comedy/1', 'Scott Pilgrim vs. The World'),\n    service.saveItem('movies/comedy/2', 'The Princess Bride'),\n    service.saveItem('songs/metal/1', 'Who Bit the Moon'),\n    service.saveItem('songs/metal/2', 'Deception - Concealing Fate, Pt. 2'),\n]);\n\nthis.cache.removeItems('songs/metal/*');\n...\n```\n\n#### Cached promise existence\n\nIf you need to check whether or not an item has been cached, ignoring whether or not it's expired, you can use the `itemExists` method.\n\n```ts\n...\nlet key = 'some-promise';\n\nlet exists = await this.cache.itemExists(key); // returns either a boolean indicating whether it exists or not, or an error message\n...\n```\n\n#### Raw cached item\n\nIf you ever need to get a cached item regardless of whether it's expired or not, you can use the `getRawItem` method.\n\n```ts\n...\nlet key = 'some-promise';\n\nlet item = await this.cache.getRawItem(key);\n...\n```\n\nThere's also the `getRawItems` method, which returns an array of the raw cached items.\n```ts\n...\nlet rawItems = await this.cache.getRawItems();\nlet firstItem = rawItems[0]; //Has the properties: key, value, expires, type, groupKey\n...\n```\n\n### Other\n\n#### Cache entries grouping\n\nAt times you may need to clear certain groups of cached items.\nFor example, if you have an infinite scroll list with a lot of items and the user triggers a pull to refresh, you may want to delete all of the cached list items. To do this, you can supply a group key as the 3rd parameter of `loadFromObservable`.\n\n```ts\n...\nloadList(pageNumber) {\n    let url = \"http://google.com/?page=\" + pageNumber;\n    let cacheKey = url;\n    let groupKey = \"googleSearchPages\"\n\n    let request = this.http.get(url);\n    return this.cache.loadFromObservable(cacheKey, request, groupKey);\n}\n...\n```\n\nThen when pull to refresh is triggered, you can use the `clearGroup` method and pass in your group key.\n\n```ts\n...\npullToRefresh() {\n    this.cache.clearGroup(\"googleSearchPages\");\n}\n...\n```\n\n#### Set custom TTL for single request\n\nIf you want a custom TTL for a single request, you can pass it as the fourth parameter.\n\n```ts\nlet ttl = 60 * 60 * 24 * 7; // TTL in seconds for one week\nlet request = this.http.get(url);\n\nreturn this.cache.loadFromObservable(cacheKey, request, groupKey, ttl);\n```\n\n#### Set default TTL\n\n```ts\nthis.cache.setDefaultTTL(60 * 60); //set the default cache TTL for 1 hour\n```\n\n#### Delete expired entries\n\nIt's automatically done on every startup, but you can do it manually.\n\n```ts\nthis.cache.clearExpired();\n```\n\n#### Delete all entries\n\n**!Important!**\n\nMake sure that you have a `keyPrefix` set in the CacheModule config, otherwise this will clear everything in Ionic Storage.\n\n```ts\nthis.cache.clearAll();\n```\n\n#### Disable cache\n\nYou can disable cache without any issues, it will pass all of the original Observables through and all Promises will be rejected.\n\n```ts\nthis.cache.enableCache(false);\n```\n\n#### Disable offline invalidation\n\nYou can also disable invalidating cached items when the device is offline.\n\n```ts\nthis.cache.setOfflineInvalidate(false);\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Nodonisko/ionic-cache.git"
  },
  "scripts": {
    "build": "rimraf dist && ngc",
    "lint": "tslint \"src/**/*.ts\"",
    "prepublishOnly": "npm run lint && npm run build",
    "test": "karma start karma.conf.js --single-run",
    "test:watch": "karma start karma.conf.js"
  },
  "typings": "dist/index.d.ts",
  "version": "3.1.2"
}
